

/* ###################################################################################################### */
\ir '../intershop/db/010-trm.sql'
\ir './set-signal-color.sql'
-- \ir './test-begin.sql'
-- \pset pager on
\timing off
\set filename 200-setup.sql
-- -- \set ECHO queries

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 1 }———:reset
drop schema if exists FM cascade; create schema FM;


-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 2 }———:reset
create domain FM.positive_integer  as integer  check ( value > 0                   );
create domain FM.nonempty_text     as text     check ( value ~ '.+'                );
create domain FM.component_name    as text     check ( value ~ '^°.+'              );
create domain FM.verb_name         as text     check ( value ~ '^\^.+'             );
create domain FM.aspect_name       as text     check ( value ~ '^:.+'              );
create domain FM.topic_name        as text     check ( value ~ '^°.+'              ); -- i.e., component
create domain FM.focus_name        as text     check ( value ~ '^[:^].+'           ); -- i.e., verb or aspect
create domain FM.atom_name         as text     check ( value ~ '^[°^:].+'          ); -- i.e., component, verb, or aspect
create domain FM.sigil             as text     check ( value ~ '^[°^:]$'           );
create domain FM.sigilcombo        as text     check ( value ~ '^([°^:])|(°[^:])$' );


-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 6 }———:reset
create table FM.kinds (
    kind      FM.nonempty_text   not null  unique,
    sigil     FM.sigilcombo      not null  unique,
    comment   FM.nonempty_text,
  primary key ( kind ) );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 6 }———:reset
-- ### TAINT add check that sigil matches kind
create table FM.atoms (
    atom      FM.atom_name      not null  unique,
    kind      text              not null  references FM.kinds ( kind ),
    comment   FM.nonempty_text,
  primary key ( atom ) );


-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 6 }———:reset
-- ### TAINT add constraint to check that sigils, kinds match
-- ### TAINT add constraint to check that exactly one state has dflt = true
-- ### TAINT add constraint to check that all events have dflt = false (or null)
create table FM.pairs (
    topic       FM.topic_name   not null  references FM.atoms ( atom ),
    focus       FM.focus_name   not null  references FM.atoms ( atom ),
    kind        text            not null  references FM.kinds ( kind ),
    dflt        boolean         not null  default false,
    comment     FM.nonempty_text,
  primary key ( topic, focus )
  -- constraint on ( topic ) check
  );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 9 }———:reset
create table FM.transition_terms (
    termid            bigint generated by default as identity primary key,
    topic             FM.topic_name  not null,
    focus             FM.focus_name  not null,
    predicate         jsonb         not null  default 'true'::jsonb,
  unique ( topic, focus, predicate ),
  foreign key ( topic, focus ) references FM.pairs );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 9 }———:reset
create table FM.transition_clausids (
    clausid           bigint generated by default as identity primary key,
    comment           text );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 9 }———:reset
create table FM.transition_termids_and_clausids (
    termid            bigint  not null references FM.transition_terms    ( termid  ),
    clausid           bigint  not null references FM.transition_clausids  ( clausid ),
  primary key ( termid, clausid ) );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 9 }———:reset
create table FM.transition_phrasids (
    phrasid           bigint  generated by default as identity primary key,
    cond_clausid      bigint  not null references FM.transition_clausids ( clausid ),
    actn_clausid      bigint  not null references FM.transition_clausids ( clausid ),
  unique ( cond_clausid, actn_clausid ) );

-- ---------------------------------------------------------------------------------------------------------
create function FM.get_last_phrasid() returns bigint volatile language sql as $$
  select max( clausid ) from FM.transition_clausids limit 1; $$;

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 9 }———:reset
create view FM.transition_clauses as ( select
    TRM.termid      as termid,
    IDS.clausid     as clausid,
    TRM.topic       as topic,
    TRM.focus       as focus,
    TRM.predicate   as predicate,
    CID.comment     as comment
  from FM.transition_terms                     as TRM
  left join FM.transition_termids_and_clausids as IDS  on ( TRM.termid = IDS.termid  )
  left join FM.transition_clausids             as CID on ( IDS.clausid = CID.clausid ) )
  ;

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 9 }———:reset
create view FM.transition_phrases as ( select
    cond.termid         as cond_termid,
    cond.clausid        as cond_clausid,
    actn.termid         as actn_termid,
    actn.clausid        as actn_clausid,
    cond.topic          as cond_topic,
    cond.focus          as cond_focus,
    cond.predicate      as cond_predicate,
    actn.topic          as actn_topic,
    actn.focus          as actn_focus,
    actn.predicate      as actn_predicate
    -- cond.comment       as cond_comment,
    -- actn.comment        as actn_comment
  from FM.transition_clauses       as cond
  join FM.transition_phrasids      as phrase on ( cond.clausid         = phrase.cond_clausid )
  left join FM.transition_clauses  as actn   on ( phrase.actn_clausid  = actn.clausid )
  order by cond_clausid, cond_termid );

-- ---------------------------------------------------------------------------------------------------------
create function FM._get_transition_clause_kind( cond_phrasid bigint, actn_phrasid bigint )
  returns text immutable parallel safe language sql as $$
  select
    case
      when cond_phrasid is      null and actn_phrasid is      null  then  'orphan'
      when cond_phrasid is  not null and actn_phrasid is  not null  then  'intermediate'
      when cond_phrasid is  not null                                then  'condition'
      else                                                                'action'
      end; $$;

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 9 }———:reset
create view FM.transition_clauses_and_phrases as ( select
    term.termid           as termid,
    IDS.clausid           as clausid,
    cond_phrase.phrasid   as cond_phrasid,
    actn_phrase.phrasid   as actn_phrasid,
    p.phrasid             as phrasid,
    ck.kind               as kind,
    term.topic            as topic,
    term.focus            as focus,
    term.predicate        as predicate,
    CID.comment           as comment
  from FM.transition_terms                     as term
  left join FM.transition_termids_and_clausids as IDS  on ( term.termid = IDS.termid  )
  left join FM.transition_clausids             as CID on ( IDS.clausid = CID.clausid )
  left join FM.transition_phrasids             as cond_phrase on ( IDS.clausid = cond_phrase.cond_clausid )
  left join FM.transition_phrasids             as actn_phrase on ( IDS.clausid = actn_phrase.actn_clausid ),
  lateral coalesce( cond_phrase.phrasid, actn_phrase.phrasid ) as p ( phrasid ),
  lateral FM._get_transition_clause_kind(
    cond_phrase.phrasid,
    actn_phrase.phrasid )                     as ck ( kind ) );


-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
create function FM.add_atom( ¶atom FM.atom_name, ¶kind text, ¶comment text )
  -- ### TAINT should check that kind and sigil match
  returns boolean volatile language plpgsql as $$
  begin
    insert into FM.atoms ( atom, kind, comment ) values
      ( ¶atom, ¶kind, ¶comment );
    return found;
  end; $$;

comment on function FM.add_atom( FM.atom_name, text, text ) is 'Given a name, and an optional comment,
register the atom with table `FM.atoms`. In case the atom has already been registered, an error will
be thrown.';

-- ---------------------------------------------------------------------------------------------------------
create function FM.add_pair(
  ¶topic FM.topic_name, ¶focus FM.focus_name, ¶kind text, ¶dflt boolean, ¶comment text )
  -- ### TAINT consider to split into two functions to add states, actions
  -- ### TAINT should check that kind and sigil match
  returns boolean volatile language plpgsql as $$
  begin
    insert into FM.pairs ( topic, focus, kind, dflt, comment ) values
      ( ¶topic, ¶focus, ¶kind, ¶dflt, ¶comment );
    return found;
  end; $$;

comment on function FM.add_pair( FM.topic_name, FM.focus_name, text, boolean, text ) is 'Given a topic, a
focus, a kind, a default flag (indicating whether the new state is a default state), and an optional
comment, register the pair with table `FM.pairs`. In case the atom has already been registered, an error
will be thrown.';

-- ---------------------------------------------------------------------------------------------------------
create function FM.add_transition_term( ¶topic FM.topic_name, ¶focus FM.focus_name, ¶predicate jsonb )
  returns bigint volatile language plpgsql as $$
  declare
    R  bigint :=  null;
  begin
    insert into FM.transition_terms ( topic, focus, predicate ) values
      ( ¶topic, ¶focus, ¶predicate ) on conflict do nothing returning termid into R;
    if R is null then
      select termid from FM.transition_terms where
        ( topic, focus, predicate ) = ( ¶topic, ¶focus, ¶predicate ) into R;
      end if;
    return R;
  end; $$;

comment on function FM.add_transition_term( FM.topic_name, FM.focus_name, jsonb ) is 'Given a topic, a focus
and a predicate, make sure the triplet is registered in table `FM.transition_terms` and return its
`termid`.';

-- -- ---------------------------------------------------------------------------------------------------------
-- create function FM.add_transition( ¶cond_topic text, ¶cond_focus text, ¶actn_topic text, ¶actn_focus text )
--   returns void volatile language plpgsql as $$
--   declare
--   begin
--   end; $$;


-- ******************************************************************************
\echo :signal ———{ :filename 6 }———:reset
insert into FM.kinds ( kind, sigil, comment ) values
  ( 'component',  '°',  'models interacting parts of the system'            ),
  ( 'verb',       '^',  'models what parts of the system can do'            ),
  ( 'aspect',     ':',  'models malleable phases of components'             ),
  ( 'event',      '°^', 'models ex- and internal actuations of the system'  ),
  ( 'state',      '°:', 'models static and dynamic postures of the system'  );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 10 }———:reset
do $$ begin
  perform FM.add_atom( '°FSM',       'component',  'pseudo-component for the automaton itself' );
  perform FM.add_atom( ':IDLE',      'aspect',     'when the automaton is not in use'          );
  perform FM.add_atom( ':ACTIVE',    'aspect',     'when the automaton is in use'              );
  perform FM.add_atom( '^RESET',     'verb',       'put the automaton in its initial state'    );
  perform FM.add_atom( '^START',     'verb',       'start the automaton'                       );
  -- -------------------------------------------------------------------------------------------------------
  perform FM.add_pair(  '°FSM', ':IDLE',    'state',  true,   'the automaton is not in use'               );
  perform FM.add_pair(  '°FSM', ':ACTIVE',  'state',  false,  'the automaton is in use'                   );
  perform FM.add_pair(  '°FSM', '^RESET',   'event',  false,  'reset the automaton to its initial state'  );
  perform FM.add_pair(  '°FSM', '^START',   'event',  false,  'start the automaton'                       );
  -- -------------------------------------------------------------------------------------------------------
  perform FM.add_transition_term(  '°FSM',   ':IDLE',    'true'  );
  perform FM.add_transition_term(  '°FSM',   '^RESET',   'true'  );
  perform FM.add_transition_term(  '°FSM',   ':ACTIVE',  'true'  );
  perform FM.add_transition_term(  '°FSM',   '^START',   'true'  );
  end; $$;


-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 10 }———:reset
insert into FM.transition_clausids ( clausid, comment ) values
  ( 1, 'FSM initialisation conditions'  ),
  ( 2, 'FSM initialisation actions'     );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 10 }———:reset
insert into FM.transition_termids_and_clausids ( termid, clausid ) values
  ( 1, 1 ),
  ( 2, 1 ),
  ( 3, 2 ),
  ( 4, 2 );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 10 }———:reset
insert into FM.transition_phrasids ( phrasid, cond_clausid, actn_clausid ) values
  ( 1, 1, 2 );


/* ###################################################################################################### */
\echo :red ———{ :filename 13 }———:reset
\quit

/* ###################################################################################################### */
/* ###################################################################################################### */
/* ###################################################################################################### */
/* ###################################################################################################### */
/* ###################################################################################################### */
/* ###################################################################################################### */

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 9 }———:reset
create table FM.transitions_and_actions (
    cond_termid     bigint  not null references FM.transition_terms ( termid ),
    actn_termid     bigint  not null references FM.transition_terms ( termid ),
  primary key ( cond_termid, actn_termid ) );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 9 }———:reset
create view FM.transitions as ( select
    TE.termid          as TE_termid,
    TE.topic            as TE_topic,
    TE.focus            as TE_focus,
    TE.predicate        as TE_predicate,
    TP.cond_termid  as TP_cond_termid,
    TP.actn_termid   as TP_actn_termid,
    TA.cond_termid  as TA_cond_termid,
    TA.actn_termid   as TA_actn_termid
  from FM.transition_terms          as TE
  left join FM.transitions_and_actions as TP on ( TE.termid = TP.cond_termid )
  left join FM.transitions_and_actions as TA on ( TE.termid = TA.actn_termid )
  -- order by clausid, id
  );

-- -- ---------------------------------------------------------------------------------------------------------
-- \echo :signal ———{ :filename 9 }———:reset
-- create view FM.transition_premises as ( select
--     *
--   from FM.transition_terms
--   where action is not null
--   order by clausid, id );

-- -- comment on view FM.transition_premises is 'lists '

-- -- ---------------------------------------------------------------------------------------------------------
-- \echo :signal ———{ :filename 9 }———:reset
-- create view FM.transition_actions as ( select
--     *
--   from FM.transition_terms
--   where action is null
--   order by clausid, id );

-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 10 }———:reset
-- TAINT add constraint to ensure only events, not other pair kinds, are entered
-- OTOH should be clear from domains used for names
create table FM.eventlog (
    id          bigint generated by default as identity primary key,
    t           timestamp with time zone  not null default now(),
    topic       FM.component_name          not null,
    focus       FM.verb_name               not null,
  foreign key ( topic, focus ) references FM.pairs ( topic, focus ) );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 11 }———:reset
create table FM.statelog (
    id          bigint generated by default as identity primary key,
    t           timestamp with time zone  not null default now(),
    topic       FM.component_name          not null,
    focus       FM.aspect_name             not null,
  foreign key ( topic, focus ) references FM.pairs ( topic, focus ) );


-- =========================================================================================================
-- INITIAL DATA
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 6 }———:reset
insert into FM.kinds ( kind, sigil, comment ) values
  ( 'component',  '°',  'models interacting parts of the system'            ),
  ( 'verb',       '^',  'models what parts of the system can do'            ),
  ( 'aspect',     ':',  'models malleable phases of components'             ),
  ( 'event',      '°^', 'models ex- and internal actuations of the system'  ),
  ( 'state',      '°:', 'models static and dynamic postures of the system'  );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 6 }———:reset
insert into FM.atoms ( atom, kind, comment ) values
  ( '°FSM',       'component',  'pseudo-component for the automaton itself' ),
  ( ':IDLE',      'aspect',     'when the automaton is not in use'          ),
  ( ':ACTIVE',    'aspect',     'when the automaton is in use'              ),
  ( '^RESET',     'verb',       'put the automaton in its initial state'    );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 6 }———:reset
insert into FM.pairs ( topic, focus, kind, dflt, comment ) values
  ( '°FSM',     ':IDLE',      'state',  true,    'the automaton is not in use'                ),
  ( '°FSM',     ':ACTIVE',    'state',  false,   'the automaton is in use'                    ),
  ( '°FSM',     '^RESET',     'event',  false,   'reset the automaton to its initial state'   );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 10 }———:reset
insert into FM.transition_terms ( termid, topic, focus, action ) values
  ( 1, '°FSM',  ':IDLE',    2     ),
  ( 1, '°FSM',  '^RESET',   2     ),
  ( 2, '°FSM',  ':ACTIVE',  null  );


/* ###################################################################################################### */
\echo :red ———{ :filename 13 }———:reset
\quit

