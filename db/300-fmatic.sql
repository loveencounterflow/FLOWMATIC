

/* ###################################################################################################### */
\ir '../intershop/db/010-trm.sql'
\ir './set-signal-color.sql'
-- \ir './test-begin.sql'
-- \pset pager on
\timing off
\set filename 300-FMAT.sql
-- -- \set ECHO queries

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 1 }———:reset
drop schema if exists FMAT cascade; create schema FMAT;


-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 2 }———:reset
-- ### TAINT use intershop.ptv variables to make configurable?
create domain FMAT.positive_integer as integer  check ( value > 0                   );
create domain FMAT.nonempty_text    as text     check ( value ~ '.+'                );
create domain FMAT.absolute_path    as text     check (
  ( value = '/' ) or ( value ~ '^/.*[^/]$' and value !~ '//' ) );

comment on domain FMAT.absolute_path is 'Data type for FlowMatic paths (qualified names); must be either a
slash (for the root element) or else start with a slash, followed by at least one character other than a
slash, not contain any slash directly followed by another slash, and not end in a slash.';


-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 3 }———:reset
-- ### TAINT find better term than 'rolegroup'
create table FMAT.rolegroups (
    rolegroup   FMAT.nonempty_text  not null  unique,
    comment     FMAT.nonempty_text,
  primary key ( rolegroup ) );

comment on table FMAT.rolegroups is 'XXXXXXXXXXXXXXXXXXXXXX';

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 4 }———:reset
insert into FMAT.rolegroups ( rolegroup, comment ) values
  ( 'rule',         'XXX' ),
  -- ### TAINT find better term than 'declaration' ('rules' are likewise 'declared')
  ( 'declaration',  'XXX' );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 3 }———:reset
create table FMAT.roles (
    rolegroup   FMAT.nonempty_text    not null references FMAT.rolegroups ( rolegroup ),
    priority    FMAT.positive_integer not null,
    role        FMAT.nonempty_text    not null  unique,
    comment     FMAT.nonempty_text,
  primary key ( role ) );
create unique index on FMAT.roles ( role, priority );
comment on table FMAT.roles is 'Provides roles of FlowMatic components.';

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 4 }———:reset
insert into FMAT.roles ( rolegroup, priority, role, comment ) values
  ( 'declaration',  1,  'action',     'xxxx' ),
  ( 'declaration',  2,  'state',      'xxxx' ),
  ( 'declaration',  3,  'component',  'xxxx' ),
  ( 'rule',         4,  'premise',    'xxxx' ),
  ( 'rule',         5,  'trigger',    'xxxx' ),
  ( 'rule',         6,  'effect',     'xxxx' ),
  ( 'rule',         7,  'move',       'xxxx' );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 5 }———:reset
-- ### TAINT add check that sigil matches role
create table FMAT.rulids (
  rulid bigint generated by default as identity primary key );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 5 }———:reset
create function FMAT._is_rulid( ¶rulid bigint ) returns boolean stable language sql as $$
  select exists ( select 1 from FMAT.rulids where rulid = ¶rulid ); $$;

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 5 }———:reset
-- ### TAINT add check that sigil matches role
create table FMAT.parts (
    partid    bigint                  generated by default as identity primary key,
    path      FMAT.absolute_path      not null,
    role      text                    not null  references FMAT.roles ( role ),
    rulid     FMAT.positive_integer,
    quality   text,
    comment   FMAT.nonempty_text,
    constraint "xxx" check (
      -- ### TAINT use rolegroup instead of listing terms
      ( role in ( 'premise', 'trigger', 'effect', 'move' ) and FMAT._is_rulid( rulid ) )
        or
      ( role in ( 'component', 'state', 'action' ) and ( rulid is null ) ) )
    );

-- thx to https://stackoverflow.com/a/8289253/7568091 (as usual)
-- thx to https://dba.stackexchange.com/a/9760/126933 (as usual)
-- ### TAINT think about best ordering of fields
create unique index "unique (role,path,quality) where rulid is null" on
  FMAT.parts ( role, path, quality ) where rulid is null;
create unique index "unique (role,path,quality,rulid) where rulid is not null" on
  FMAT.parts ( role, path, quality, rulid ) where rulid is not null;

comment on table FMAT.parts is 'XXXXXXXXXXXXXXXXXXXXXX';


-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 5 }———:reset
insert into FMAT.rulids ( rulid ) values ( 1 );
insert into FMAT.rulids ( rulid ) values ( 2 );
insert into FMAT.rulids ( rulid ) values ( 3 );
insert into FMAT.rulids ( rulid ) values ( 4 );
insert into FMAT.rulids ( rulid ) values ( 5 );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 6 }———:reset
insert into FMAT.parts ( rulid, role, path, quality ) values
  ( null, 'state',    '/apps/blink/light',          ':off'                                                ),
  ( null, 'state',    '/apps/blink/light',          ':on'                                                 ),
  ( null, 'action',   '/apps/blink/light',          'toggle()'                                            ),
  ( null, 'state',    '/apps/blink/plug',           ':unplugged'                                          ),
  ( null, 'state',    '/apps/blink/plug',           ':inserted'                                           ),
  ( null, 'action',   '/apps/blink/timer',          'tick()'                                              ),
  ( 1,    'premise',  '/apps/blink/light',          ':on'                                                 ),
  ( 1,    'trigger',  '/apps/blink/light',          'toggle()'                                            ),
  ( 1,    'effect',   '/apps/blink/light',          ':off'                                                ),
  ( 2,    'premise',  '/apps/blink/plug',           ':inserted'                                           ),
  ( 2,    'premise',  '/apps/blink/light',          ':off'                                                ),
  ( 2,    'trigger',  '/apps/blink/light',          'toggle()'                                            ),
  ( 2,    'effect',   '/apps/blink/light',          ':on'                                                 ),
  ( 3,    'trigger',  '/apps/blink/timer',          'tick()'                                              ),
  ( 3,    'move',     '/apps/blink/light',          'toggle()'                                            ),
  ( 4,    'premise',  '/apps/blink/plug',           ':unplugged'                                          ),
  ( 4,    'trigger',  '/',                          '~enter()'                                            ),
  ( 4,    'effect',   '/apps/blink/light',          ':off'                                                ),
  ( 5,    'premise',  '/apps/blink/plug',           ':unplugged'                                          ),
  ( 5,    'trigger',  '/',                          '~enter()'                                            ),
  ( 5,    'premise',  '/apps/blink/light',          ':on'                                                 ),
  ( 5,    'move',     '/apps/blink/light',          '~error("impossible state")'                          );

select p.partid, p.rulid, r.rolegroup, r.priority, p.role, p.path, p.quality from FMAT.parts p join FMAT.roles as r using ( role ) order by r.priority,     p.path,   p.rulid,    p.quality;
select p.partid, p.rulid, r.rolegroup, r.priority, p.role, p.path, p.quality from FMAT.parts p join FMAT.roles as r using ( role ) order by p.path,     r.priority,   p.rulid,    p.quality;

/* ###################################################################################################### */
\echo :red ———{ :filename 13 }———:reset
\quit

